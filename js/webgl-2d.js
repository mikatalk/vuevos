(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["webgl-2d"],{a047:function(e,t,n){},d5d5:function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"view view-webgl-2d"},[n("title-box",[e._v("Make an Egg using WebGL 2D ")]),n("section",{staticClass:"square-container"},[n("egg-webgl-2d")],1),n("p",[e._v(" Got tired of the CPU yet, maybe the CPU got tired of your script? Time to move up to the WebGL and unleash the power of the GPU! ")]),n("p",[e._v(" One common mis-conception about WebGL is that it's for 3D only. In a way it is true as the 3D rendering pipeline is part of the core architecture of WebGL with it vertex and fragment shaders. But it's also very powerful at rendering 2D layers, stacked and blended on top of each others. ")]),e._m(0),e._m(1),n("p",[e._v(" You may think it's an odd way to overcomplicate graphics rendering for a 2D output, and you would probably be right. ")]),n("p",[e._v(" But let's look at it from this perspective: A quad is two triangles. If you can draw on triangles you can draw on anything in 3D. This is a great way to get started with WebGL by putting aside some of the complexity of 3D while getting comfortable with using its shader language GLSL. ")]),n("p",[e._v(" With that said let's jump in the code and set up a Three JS 2d scene using the OrthographicCamera. "),n("c",[e._v("THREE.OrthographicCamera")]),e._v(" because it allows us to define our own shaders. ")],1),n("pre",[e._v("      "),n("code",{domProps:{innerHTML:e._s(e.highlightJS("const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst scene = new THREE.Scene();\nconst renderer = new THREE.WebGLRenderer({canvas});\nrenderer.setPixelRatio(window.devicePixelRatio);\nrenderer.render(scene, camera);\n// Create quad\nconst geometry = new THREE.PlaneGeometry(2, 2, 1, 1);\nconst material = new THREE.ShaderMaterial({...});\nconst mesh = new THREE.Mesh( geometry, material );\nscene.add(mesh);"))}},[e._v("\n      ")]),e._v("\n    ")]),n("p",[e._v(" ThreeJS allows us to get the ball rolling real quick! We create a camera, a scene and a renderer. Then we add a quad to the scene. ")]),n("p",[e._v(" Note that the quad mesh is composed of a Plane geometry and a Shader material. We use "),n("c",[e._v("THREE.ShaderMaterial")]),e._v(" because it allows us to define our own shaders. ")],1),n("p",[e._v(" Since we're just interested in modifying the rendered pixel and not affect the actual geometry at all we use a boilerplate vertex shader: ")]),n("pre",[e._v("      "),n("code",{domProps:{innerHTML:e._s(e.highlightJS("varying vec2 vUv;\nvoid main()  {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}"))}},[e._v("\n      ")]),e._v("\n    ")]),n("p",[e._v("The vertex shader has two jobs: Calculating the position of the pixel on the quad and sending the UV variable to the fragment shader using varying variables (shared variables across fragment and vertex shaders). ")]),n("p",[e._v(" Fragment shaders are executed over every pixel of your fried egg. The reason they are so powerful is because they are executed in parallel in your GPU. ")]),n("p",[e._v(" Running an execution in parallel makes you think about your code from a different perspective and because of its architecture the variable types and data strutures are different than what you may be used to in JS land. ")]),n("pre",[e._v("      "),n("code",{domProps:{innerHTML:e._s(e.highlightJS("varying vec2 vUv;\n\nfloat draw_circle_gradient(vec2 coord, float radius) {\n  return smoothstep(0.0, length(coord), radius);\n}\n\nfloat draw_circle(vec2 coord, float radius) {\n  return step(length(coord), radius);\n}\n\nvoid main()  {\n  vec3 pink = vec3(1, 0.41, 0.71);\n  vec3 white = vec3(1,1,1);\n  vec3 yellow = vec3(1,0.84,0);\n  vec3 yellowDark = vec3(0.98,0.82,0);\n\n  vec2 p = - 1.0 + 2.0 * vUv;\n  float circle = draw_circle_gradient(p+vec2(0., 0.25), 0.35);\n  circle = mix(circle, draw_circle_gradient(p +vec2(0.35, -0.1), 0.35), 0.5);\n  circle = mix(circle, draw_circle_gradient(p +vec2(-0.3, -0.2), 0.35), 0.5);\n  vec3 color = pink;\n  float eggWhite = smoothstep(0.5,0.51,circle);\n  if (eggWhite > 0.0) {\n    color = white;\n  }\n  float yolkOutline = draw_circle(p+vec2(0., 0.1), 0.35);\n  if (yolkOutline > 0.0) {\n    color = yellowDark;\n  }\n  float yolk = draw_circle(p+vec2(0., 0.1), 0.3);\n  if (yolk > 0.0) {\n    color = yellow;\n  }\n  gl_FragColor = vec4(color, 1.0);\n}"))}},[e._v("\n      ")]),e._v("\n    ")]),n("p",[e._v("Fragment shaders output is defined by the "),n("c",[e._v("main")]),e._v(" function which role is to set the RGBA (red, green, blue, alpha) values of the pixel inside a variable called "),n("c",[e._v("gl_FragColor")]),e._v(". ")],1),n("section",{staticClass:"square-container"},[n("egg-webgl-2d")],1),n("p",[e._v(" This is of course just the tip of the iceberg. It is in no way optimized and was simplidief for readability. ")]),e._m(2),n("p",[e._v(" As we just took a detour to look into a very specific use of WebGL, let's next continue frying eggs in "),n("router-link",{staticClass:"link",attrs:{to:"/webgl-3d"}},[e._v(" 3D using WebGL ")]),e._v(". ")],1),e._m(3)],1)},r=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" Because the WebGL API is pretty low level and boilerplate code can become cumbersome. We will try to avoid confusion by using the popular framework "),n("a",{staticClass:"link",attrs:{href:"https://github.com/mikatalk/vuevos/blob/main/src/eggs/EggSVGFilters.vue"}},[e._v(" Three.js")]),e._v(" and try focusing essentialy on the fragment shader. ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" Have you ever stumbled upon "),n("a",{staticClass:"link",attrs:{href:"https://www.shadertoy.com/"}},[e._v(" ShaderToy")]),e._v(" website and wondered how the heck it worked? This site uses WebGL to render a 3D quad on the screen. From there it focuses only on the fragment shader to draw on a 2D canvas. ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v(" If you want to learn more on the topic, I strongly recommend checking out the "),n("a",{staticClass:"link",attrs:{href:"https://thebookofshaders.com/"}},[e._v(" Book of Shaders ")]),e._v(" and even take it a step further and dig into signed distance functions as exlpained by "),n("a",{staticClass:"link",attrs:{href:"https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm"}},[e._v(" Inigo Quilez ")]),e._v(" in his incredibly useful articles. ")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[n("a",{staticClass:"btn",attrs:{href:"https://github.com/mikatalk/vuevos/blob/main/src/eggs/EggWebGL2D.vue"}},[e._v(" Get the code and contribute. ")])])}],i=n("e770"),o=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"egg-webgl-2d"},[n("canvas")])}],c=n("5a89"),l={name:"EggWebGL2D",mounted:function(){var e=this.$el,t=e.getBoundingClientRect().width,n=e.querySelector("canvas");n.width=t,n.height=t;var a=new c["e"](-1,1,1,-1,0,1),r=new c["h"],i=new c["g"](2,2),o={time:{value:1}},s=new c["i"]({uniforms:o,vertexShader:"\n      varying vec2 vUv;\n      void main()  {\n        vUv = uv;\n        gl_Position = vec4(position, 1.0);\n      }\n      ",fragmentShader:"\n      varying vec2 vUv;\n      uniform float time;\n      \n      float draw_circle_gradient(vec2 coord, float radius) {\n        return smoothstep(0.0, length(coord), radius);\n      }\n\n      float draw_circle(vec2 coord, float radius) {\n        return step(length(coord), radius);\n      }\n\n      void main()  {\n        vec3 pink = vec3(1, 0.41, 0.71);\n        vec3 white = vec3(1,1,1);\n        vec3 yellow = vec3(1,0.84,0);\n        vec3 yellowDark = vec3(0.98,0.82,0);\n\n        vec2 p = - 1.0 + 2.0 * vUv;\n        float circle = draw_circle_gradient(p+vec2(0., 0.25), 0.35);\n        circle = mix(circle, draw_circle_gradient(p +vec2(0.35, -0.1), 0.35), 0.5);\n        circle = mix(circle, draw_circle_gradient(p +vec2(-0.3, -0.2), 0.35), 0.5);\n        vec3 color = pink;\n        float eggWhite = smoothstep(0.5,0.51,circle);\n        if (eggWhite > 0.0) {\n          color = white;\n        }\n        float yolkOutline = draw_circle(p+vec2(0., 0.1), 0.35);\n        if (yolkOutline > 0.0) {\n          color = yellowDark;\n        }\n        float yolk = draw_circle(p+vec2(0., 0.1), 0.3);\n        if (yolk > 0.0) {\n          color = yellow;\n        }\n        gl_FragColor = vec4(color, 1.0);\n      }\n\n      "}),l=new c["c"](i,s);r.add(l);var d=new c["k"]({canvas:n});d.setPixelRatio(window.devicePixelRatio),d.render(r,a)},beforeDestroy:function(){var e=this.$el;while(e&&e.lastChild)e.removeChild(e.lastChild)}},d=l,h=(n("e427"),n("2877")),v=Object(h["a"])(d,o,s,!1,null,null,null),u=v.exports,g=n("5a37"),f=n("72e3"),p=n("1cf6"),w={name:"WebGL2D",components:{"egg-webgl-2d":u,"title-box":f["a"],c:p["a"]},data:function(){return{snippet1:i["a"]}},methods:{highlightJS:g["b"]}},m=w,_=(n("eb20"),Object(h["a"])(m,a,r,!1,null,null,null));t["default"]=_.exports},e427:function(e,t,n){"use strict";n("a047")},eb20:function(e,t,n){"use strict";n("f84c")},f84c:function(e,t,n){}}]);
//# sourceMappingURL=webgl-2d.js.map